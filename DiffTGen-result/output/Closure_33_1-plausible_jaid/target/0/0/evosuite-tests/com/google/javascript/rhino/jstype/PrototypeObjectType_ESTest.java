/*
 * This file was automatically generated by EvoSuite
 * Sat Mar 28 11:26:48 GMT 2020
 */

package com.google.javascript.rhino.jstype;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.rhino.ErrorReporter;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.AllType;
import com.google.javascript.rhino.jstype.EnumType;
import com.google.javascript.rhino.jstype.ErrorFunctionType;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.IndexedType;
import com.google.javascript.rhino.jstype.InstanceObjectType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.NoObjectType;
import com.google.javascript.rhino.jstype.NoResolvedType;
import com.google.javascript.rhino.jstype.NumberType;
import com.google.javascript.rhino.jstype.ObjectType;
import com.google.javascript.rhino.jstype.ParameterizedType;
import com.google.javascript.rhino.jstype.PrototypeObjectType;
import com.google.javascript.rhino.jstype.RecordType;
import com.google.javascript.rhino.jstype.RecordTypeBuilder;
import com.google.javascript.rhino.jstype.SimpleSlot;
import com.google.javascript.rhino.jstype.StaticScope;
import com.google.javascript.rhino.jstype.VoidType;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class PrototypeObjectType_ESTest extends PrototypeObjectType_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "");
      ErrorFunctionType errorFunctionType1 = (ErrorFunctionType)errorFunctionType0.toMaybeFunctionType();
      boolean boolean0 = errorFunctionType0.isRegexpType();
      boolean boolean1 = errorFunctionType0.hasImplementedInterfaces();
      errorFunctionType1.setPrettyPrint(true);
      boolean boolean2 = errorFunctionType1.isPropertyInExterns(", ");
      errorFunctionType1.setOwnerFunction(errorFunctionType0);
      ObjectType.Property objectType_Property0 = errorFunctionType0.getSlot("}");
      boolean boolean3 = errorFunctionType0.isPropertyTypeDeclared("}");
      NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
      NoResolvedType noResolvedType1 = (NoResolvedType)JSType.filterNoResolvedType(noResolvedType0);
      boolean boolean4 = errorFunctionType1.isSubtype(noResolvedType1);
      noResolvedType0.setPrettyPrint(false);
      boolean boolean5 = noResolvedType1.isUnknownType();
      Node node0 = Node.newString(1, "#(R#@[", Integer.MAX_VALUE, 1872);
      boolean boolean6 = noResolvedType0.defineProperty("Not declared as a type name", noResolvedType1, true, node0);
      FunctionType functionType0 = errorFunctionType0.getConstructor();
      boolean boolean7 = noResolvedType0.matchesNumberContext();
      JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry((ErrorReporter) null);
      ParameterizedType parameterizedType0 = jSTypeRegistry1.createParameterizedType(noResolvedType0, errorFunctionType0);
      noResolvedType0.setImplicitPrototype(parameterizedType0);
      Node node1 = errorFunctionType0.getPropertyNode("Unknown class name");
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "obpY]{q ");
      ObjectType objectType0 = errorFunctionType0.getInstanceType();
      simpleErrorReporter0.error("@+hEq", "valueOf", (-3744), 1277);
      boolean boolean0 = jSTypeRegistry0.declareType("Unknown class name", errorFunctionType0);
      PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, "obpY]{q ", objectType0, false);
      boolean boolean1 = prototypeObjectType0.matchesObjectContext();
      boolean boolean2 = errorFunctionType0.isPropertyTypeDeclared("Not declared as a type name");
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      simpleErrorReporter0.warning("", (String) null, 118, 118);
      ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "NUMBER_OBJECT_FUNCTION_TYPE");
      ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(errorFunctionType0, errorFunctionType0);
      String string0 = parameterizedType0.getDisplayName();
      JSType.TypePair jSType_TypePair0 = errorFunctionType0.getTypesUnderEquality(parameterizedType0);
      simpleErrorReporter0.warning("Unknown class name", "", 1, 337);
      ErrorFunctionType errorFunctionType1 = (ErrorFunctionType)errorFunctionType0.toMaybeFunctionType();
      errorFunctionType0.clearCachedValues();
      ErrorFunctionType errorFunctionType2 = (ErrorFunctionType)errorFunctionType1.autobox();
      PrototypeObjectType prototypeObjectType0 = (PrototypeObjectType)jSTypeRegistry0.createNativeAnonymousObjectType();
      simpleErrorReporter0.warning("?hICbP", "Named type with empty name component", 4, 2);
      errorFunctionType1.setPrettyPrint(true);
      boolean boolean0 = errorFunctionType1.matchesUint32Context();
      boolean boolean1 = errorFunctionType0.matchesObjectContext();
      String string1 = errorFunctionType1.getReferenceName();
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "");
      ObjectType objectType0 = ObjectType.cast(errorFunctionType0);
      IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, objectType0, objectType0);
      ErrorFunctionType errorFunctionType1 = (ErrorFunctionType)indexedType0.toMaybeFunctionType();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(errorFunctionType1, indexedType0);
      InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0, true);
      functionType0.clearCachedValues();
      boolean boolean0 = instanceObjectType0.hasCachedValues();
      SimpleSlot simpleSlot0 = new SimpleSlot("", functionType0, false);
      JSDocInfo jSDocInfo0 = simpleSlot0.getJSDocInfo();
      errorFunctionType0.setPropertyJSDocInfo("", (JSDocInfo) null);
      JSDocInfo jSDocInfo1 = errorFunctionType0.getOwnPropertyJSDocInfo("~0");
      // Undeclared exception!
      try { 
        instanceObjectType0.getPropertyNode((String) null);
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.TreeMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ",~5");
      FunctionType functionType0 = errorFunctionType0.getBindReturnType(65377);
      InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
      instanceObjectType0.setOwnerFunction(functionType0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_FUNCTION_TYPE;
      JSType jSType0 = functionType0.getNativeType(jSTypeNative0);
      simpleErrorReporter0.warning("?", "Unknown class name", 1, (-4317));
      boolean boolean0 = instanceObjectType0.isBooleanObjectType();
      boolean boolean1 = errorFunctionType0.isArrayType();
      simpleErrorReporter0.error("Not declared as a type name", ")TF/^K{f/IQlUQbZHm", 65377, (-4433));
      int int0 = instanceObjectType0.getPropertiesCount();
      Iterable<ObjectType> iterable0 = functionType0.getCtorImplementedInterfaces();
      boolean boolean2 = functionType0.hasOwnProperty("Named type with empty name component");
      boolean boolean3 = functionType0.isPropertyTypeInferred("Not declared as a type name");
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
      JSDocInfo jSDocInfo0 = noResolvedType0.getJSDocInfo();
      simpleErrorReporter0.error("(^|\n)# Your branch is behind .*\n", (String) null, 1, 0);
      noResolvedType0.setJSDocInfo((JSDocInfo) null);
      ObjectType.Property objectType_Property0 = noResolvedType0.getSlot("9#:Cn(#,*");
      Locale locale0 = Locale.US;
      Set<String> set0 = locale0.getUnicodeLocaleKeys();
      Set<String> set1 = locale0.getUnicodeLocaleAttributes();
      noResolvedType0.collectPropertyNames(set1);
      ObjectType objectType0 = noResolvedType0.getImplicitPrototype();
      noResolvedType0.collectPropertyNames(set1);
      Set<String> set2 = noResolvedType0.getOwnPropertyNames();
      noResolvedType0.collectPropertyNames(set0);
      Iterable<ObjectType> iterable0 = noResolvedType0.getCtorExtendedInterfaces();
      boolean boolean0 = noResolvedType0.defineProperty("", (JSType) null, true, (Node) null);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) noResolvedType0, (List<JSType>) linkedList0);
      int int0 = functionType0.getPropertiesCount();
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      simpleErrorReporter0.warning("t'FrAePv[9Wt ", (String) null, (-1714), 0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "wN77m$: Ltx a.t");
      FunctionType functionType0 = errorFunctionType0.toMaybeFunctionType();
      InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
      boolean boolean0 = instanceObjectType0.isSubtype(functionType0);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "wVi");
      ObjectType objectType0 = errorFunctionType0.getPrototype();
      simpleErrorReporter0.warning("Named type with empty name component", "wVi", 0, 0);
      boolean boolean0 = errorFunctionType0.isNumberObjectType();
      boolean boolean1 = jSTypeRegistry0.canPropertyBeDefined(errorFunctionType0, (String) null);
      int int0 = errorFunctionType0.getMinArguments();
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      boolean boolean2 = errorFunctionType0.equals((Object) null);
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) errorFunctionType0, (List<JSType>) linkedList0);
      JSType.TypePair jSType_TypePair0 = errorFunctionType0.getTypesUnderShallowInequality(functionType0);
      ObjectType.Property objectType_Property0 = errorFunctionType0.getSlot("");
      boolean boolean3 = errorFunctionType0.hasCachedValues();
      SimpleSlot simpleSlot0 = new SimpleSlot("~(*@eX\"u", errorFunctionType0, true);
      JSDocInfo jSDocInfo0 = simpleSlot0.getJSDocInfo();
      errorFunctionType0.setPropertyJSDocInfo("K,VZJz:QsUH1L07_D'", (JSDocInfo) null);
      simpleErrorReporter0.error("Not declared as a constructor", "Named type with empty name component", (-1), 1);
      boolean boolean4 = functionType0.isNumber();
      errorFunctionType0.setPrettyPrint(false);
      JSDocInfo jSDocInfo1 = errorFunctionType0.getOwnPropertyJSDocInfo("com.google.javascript.rhino.jstype.PrototypeObjectType");
      boolean boolean5 = functionType0.isPropertyTypeDeclared("Named type with empty name component");
      boolean boolean6 = functionType0.canBeCalled();
      boolean boolean7 = functionType0.hasCachedValues();
      functionType0.setPropertyJSDocInfo("~(*@eX\"u", (JSDocInfo) null);
      boolean boolean8 = functionType0.isSubtype(objectType0);
      ObjectType.Property objectType_Property1 = errorFunctionType0.getSlot("Named type with empty name component");
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "");
      FunctionType functionType0 = errorFunctionType0.getSuperClassConstructor();
      JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
      AllType allType0 = new AllType(jSTypeRegistry1);
      JSDocInfo jSDocInfo0 = allType0.getJSDocInfo();
      functionType0.setJSDocInfo((JSDocInfo) null);
      FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(functionType0, functionType0);
      FunctionType functionType2 = JSType.toMaybeFunctionType((JSType) functionType1);
      boolean boolean0 = functionType2.isNativeObjectType();
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      jSTypeRegistry0.setLastGeneration(false);
      Node node0 = new Node(76, 76, 76);
      JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry((ErrorReporter) null);
      AllType allType0 = new AllType(jSTypeRegistry1);
      JSType jSType0 = allType0.resolveInternal((ErrorReporter) null, (StaticScope<JSType>) null);
      EnumType enumType0 = jSTypeRegistry0.createEnumType("', '", node0, jSType0);
      ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "i^");
      boolean boolean0 = errorFunctionType0.matchesStringContext();
      Set<String> set0 = errorFunctionType0.getOwnPropertyNames();
      boolean boolean1 = errorFunctionType0.hasCachedValues();
      FunctionType functionType0 = errorFunctionType0.getConstructor();
      JSType jSType1 = errorFunctionType0.unboxesTo();
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      VoidType voidType0 = new VoidType(jSTypeRegistry0);
      JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
      JSType jSType1 = JSType.getGreatestSubtype(jSType0, jSType0);
      JSType[] jSTypeArray0 = new JSType[7];
      jSTypeArray0[0] = jSType0;
      jSTypeArray0[1] = jSType1;
      jSTypeArray0[2] = (JSType) voidType0;
      jSTypeArray0[3] = (JSType) voidType0;
      jSTypeArray0[4] = jSType1;
      JSType.TypePair jSType_TypePair0 = jSType0.getTypesUnderShallowEquality(jSTypeArray0[2]);
      Iterable<ObjectType> iterable0 = jSTypeRegistry0.getEachReferenceTypeWithProperty("N5\"FJMDNF<iOiWc");
      jSTypeArray0[5] = jSType1;
      jSTypeArray0[6] = jSType0;
      FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType1, true, jSTypeArray0);
      jSType1.matchConstraint(functionType0);
      boolean boolean0 = functionType0.isArrayType();
      boolean boolean1 = functionType0.matchesObjectContext();
      FunctionType functionType1 = functionType0.getOwnerFunction();
      Set<String> set0 = functionType0.getOwnPropertyNames();
      Node node0 = Node.newNumber((double) 0);
      boolean boolean2 = functionType0.defineProperty("", jSTypeArray0[3], true, node0);
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "?!L{gtL");
      boolean boolean0 = errorFunctionType0.matchesObjectContext();
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "(^|\n)# Your branch is ahead of .*\n");
      FunctionType functionType0 = errorFunctionType0.getBindReturnType(862);
      boolean boolean0 = functionType0.hasProperty("4)PxD=HCtB");
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
      JSType jSType0 = noObjectType0.getPropertyType("Dz{BwfW| =]");
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (List<JSType>) linkedList0);
      FunctionType functionType1 = functionType0.getConstructor();
      jSTypeRegistry0.setLastGeneration(true);
      boolean boolean0 = noObjectType0.isNativeObjectType();
      functionType0.setPrettyPrint(false);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      NumberType numberType0 = new NumberType(jSTypeRegistry0);
      JSType jSType0 = numberType0.autoboxesTo();
      linkedList0.push(jSType0);
      Node node0 = jSTypeRegistry0.createParameters((List<JSType>) linkedList0);
      RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
      Iterable<ObjectType> iterable0 = recordType0.getCtorImplementedInterfaces();
  }
}
